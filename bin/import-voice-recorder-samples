let fsutil = require('togosutils/fsutil');

let indir = 'C:/backup/2020/TOGoS_Galaxy_Note_8/Voice Recorder';
let outdir = 'F:/stuff/music/work/2019/ableton-live-library/Samples/Imported/Voice Recorder';

// TODO: Maybe put walk in fsutil
// TODO: Less verbosity by default
// TODO: Force user to indicate indir or give an option indicating that they know what the defaults will do

let defaultDirCallback = (dir) => Promise.resolve(true);
let defaultWalkOptions = { parallel: false, includeDotFiles: false };
let pathSegmentSeparator = '/';

function walk(file, fileCallback, dirCallback, options) {
    if( dirCallback == null ) dirCallback = defaultDirCallback;
    if( options == null ) options = defaultWalkOptions;
    return fsutil.stat(file).then( stat => {
	if( stat.isDirectory() ) {
	    return dirCallback(file).then( shouldRecurse => {
		return shouldRecurse ? fsutil.readDir(file).then( subnames => {
		    if( !options.includeDotFiles ) subnames = subnames.filter( n => n.substr(0,1) != '.' );
		    if( options.parallel ) {
			let results = [];
			for( let f in subnames ) {
			    results.push( walk(file+pathSegmentSeparator+subnames[f], fileCallback, dirCallback, options) );
			}
			return Promise.all(results);
		    } else {
			let result = Promise.resolve();
			for( let f in subnames ) {
			    result = result.then( () => walk(file+pathSegmentSeparator+subnames[f], fileCallback, dirCallback, options) );
			}
			return result;
		    }
		}) : undefined;
	    });
	} else {
	    return fileCallback(file);
	}
    });
}

function linkOrCopy(source, dest) {
    if( source == dest ) return Promise.reject(new Error(`Source and dest files are the same: ${source}`));
    return Promise.resolve().then( () => {
	return fsutil.mkParentDirs(dest);
    }).then( () => {
	console.log(`ln "${source}" "${dest}"`);
	return fsutil.link(source, dest).catch( err => {
	    console.log(`cp "${source}" "${dest}"`);
	    return fsutil.cp(source, dest);
	//}).catch( err => {
	//    return Promise.reject(err);
	});
    }).then( () => {
	return fsutil.stat(dest);
    }).then( stat => {
	let newMode = stat.mode & ~0o222;
	return fsutil.chmod(dest, newMode);
    });
}

let copyCount = 0;

function fileCallback(infile) {
    let outfile = outdir + infile.substr(indir.length);
    let m;
    if( m = /^(.*).(mp4|m4a)$/.exec(outfile) ) {
	outfile = m[1]+".mp4";
    } else {
	// At the moment I'm /only/ interested in m4a files.
	return;
    }
    return fsutil.stat( outfile ).then( _ => true ).catch( _ => false ).then( exists => {
	if( exists ) {
	    console.log(`# ${outfile} already exists`);
	    return undefined;
	} else {
	    return linkOrCopy(infile, outfile).then( () => ++copyCount );
	}
    })
}

walk(indir, fileCallback, undefined, {parallel:false}).then( (exitCode) => {
    console.log(`# ${copyCount} files copied`);
    return 0;
}).catch( err => {
    console.error("There was a problem.");
    console.error(err.stack);
    return 1;l
}).then( exitCode => {
    process.exit(exitCode);
});
